<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Roguelite Demo</title>
  <style>
    body {
      margin: 0;
      background: #111;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      color: white;
      font-family: monospace;
    }
    canvas {
      background: #222;
      border: 1px solid #444;
    }
    #ui-floor-counter {
        position: absolute;
        top: 10px;
        left: 10px;
        font-size: 24px;
        color: #fff;
    }
    #ui-container {
        margin-top: 10px;
        display: flex;
        justify-content: space-around;
        width: 800px;
        padding: 10px;
        background-color: #333;
        border-radius: 5px;
    }
    .stat {
        font-size: 18px;
        margin: 0 10px;
    }
    .hp-bar { color: #0f0; }
    .xp-bar { color: #00f; }
    .coins { color: #ff0; }
  </style>
</head>
<body>
  <div id="ui-floor-counter">Floors: <span id="floor-count">1</span></div>
  <canvas id="gameCanvas" width="800" height="480"></canvas>
  <div id="ui-container">
      <div class="stat">HP: <span id="player-hp" class="hp-bar"></span></div>
      <div class="stat">DMG: <span id="player-dmg"></span></div>
      <div class="stat">LVL: <span id="player-lvl"></span></div>
      <div class="stat">XP: <span id="player-xp" class="xp-bar"></span></div>
      <div class="stat">COINS: <span id="player-coins" class="coins"></span></div>
  </div>

  <div id="skill-popup">
    <h2>Game Over</h2>
    <p>Floors Reached: <span id="floor-reached-display"></span></p>
    <p>You earned <span id="shard-count">0</span> total coins this run.</p>
    <p>Spend your coins on permanent upgrades.</p>
    <div id="skill-tree">
    </div>
    <button onclick="startNewGame()" class="skill-button" style="margin-top: 20px;">Start New Run</button>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const uiHp = document.getElementById("player-hp");
    const uiDmg = document.getElementById("player-dmg");
    const uiLvl = document.getElementById("player-lvl");
    const uiXp = document.getElementById("player-xp");
    const uiCoins = document.getElementById("player-coins");
    const uiFloorCount = document.getElementById("floor-count");

    // Constants
    const TILE_SIZE = 16;
    const MAP_WIDTH = 50;
    const MAP_HEIGHT = 30;
    const MAX_ROOMS = 8;
    const ROOM_MIN_SIZE = 5;
    const ROOM_MAX_SIZE = 10;
    const VIEWPORT_WIDTH_TILES = canvas.width / TILE_SIZE;
    const VIEWPORT_HEIGHT_TILES = canvas.height / TILE_SIZE;
    const MOVE_DELAY_MS = 100;
    const ENEMY_MIN_SPAWN_DIST = 2.5; 

    // Game State
    let map = [];
    let player;
    let cameraX = 0;
    let cameraY = 0;
    const pressedKeys = {};
    let lastMoveTime = 0;
    let enemies = [];
    let projectiles = [];
    let roomsList = [];
    let currentFloor = 1;
    let gameRunning = true;

    // --- Utility Classes and Functions (Dungeon Generation) ---
    // (Room, carveRoom, carveTunnel, carveH, carveV functions remain the same as previous step)
    class Room {
      constructor(x, y, w, h) {
        this.x1 = x; this.y1 = y;
        this.x2 = x + w; this.y2 = y + h;
      }
      center() {
        return [ Math.floor((this.x1 + this.x2) / 2), Math.floor((this.y1 + this.y2) / 2) ];
      }
      intersects(other) {
        return (this.x1 <= other.x2 && this.x2 >= other.x1 && this.y1 <= other.y2 && this.y2 >= other.y1);
      }
    }
    function carveRoom(room) {
      for (let y = room.y1 + 1; y < room.y2; y++) for (let x = room.x1 + 1; x < room.x2; x++) map[y][x] = 0;
    }
    function carveTunnel(x1, y1, x2, y2) {
      if (Math.random() < 0.5) { carveH(x1, x2, y1); carveV(y1, y2, x2); } else { carveV(y1, y2, x1); carveH(x1, x2, y2); }
    }
    function carveH(x1, x2, y) {
      for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) map[y][x] = 0;
    }
    function carveV(y1, y2, x) {
      for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) map[y][x] = 0;
    }

    function generateDungeon() {
      map = Array.from({ length: MAP_HEIGHT }, () => Array(MAP_WIDTH).fill(1));
      roomsList = [];
      enemies = [];
      projectiles = []; // Clear projectiles when generating new floor

      for (let i = 0; i < MAX_ROOMS; i++) {
        let w = ROOM_MIN_SIZE + Math.floor(Math.random() * (ROOM_MAX_SIZE - ROOM_MIN_SIZE));
        let h = ROOM_MIN_SIZE + Math.floor(Math.random() * (ROOM_MAX_SIZE - ROOM_MIN_SIZE));
        let x = Math.floor(Math.random() * (MAP_WIDTH - w - 1));
        let y = Math.floor(Math.random() * (MAP_HEIGHT - h - 1));
        let newRoom = new Room(x, y, w, h);
        if (roomsList.every(r => !newRoom.intersects(r))) {
          carveRoom(newRoom);
          if (roomsList.length > 0) {
            let [prevX, prevY] = roomsList[roomsList.length - 1].center();
            let [newX, newY] = newRoom.center();
            carveTunnel(prevX, prevY, newX, newY);
          }
          roomsList.push(newRoom);
        }
      }
      
      if (roomsList.length > 0) {
          const [playerX, playerY] = roomsList[0].center(); 
          if (!player) {
              // Create player for the first time
              player = new Player(playerX, playerY, "#00ff00");
          } else {
              // Move existing player to the new location
              player.x = playerX;
              player.y = playerY;
          }

          player.updateCamera();
          
          // Place stairs in the last room
          const lastRoom = roomsList[roomsList.length - 1];
          const [stairsX, stairsY] = lastRoom.center();
          // We can use a special tile ID for stairs, e.g., 2
          map[stairsY][stairsX] = 2; 
      }
    }

    function goToNextFloor() {
        currentFloor++;
        generateDungeon();
        spawnEnemies();
        updateUI();
    }
    
    // --- Player Management ---
    
    class Player {
        constructor(x, y, color) {
            this.x = x; this.y = y; this.color = color;
            this.baseHp = 100; this.maxHp = 100; this.hp = 100;
            this.baseDamage = 10; this.damage = 10;
            this.level = 1; this.xp = 0; this.xpToNextLevel = 100;
            this.coins = 0;
        }
        move(dx, dy) {
            const newX = this.x + dx;
            const newY = this.y + dy;
            if (newX >= 0 && newX < MAP_WIDTH && newY >= 0 && newY < MAP_HEIGHT) {
                if (map[newY][newX] === 1) return false; // Collision with wall

                // Check if moving into an enemy tile (basic collision for tile-based movement)
                const collisionWithEnemy = enemies.some(e => Math.floor(e.x) === newX && Math.floor(e.y) === newY);
                if (collisionWithEnemy) return false;
                
                this.x = newX;
                this.y = newY;
                this.updateCamera();

                // Check if on stairs (Tile ID 2)
                if (map[this.y][this.x] === 2) {
                    goToNextFloor();
                }
                return true;
            }
            return false;
        }
        updateCamera() {
            cameraX = this.x - Math.floor(VIEWPORT_WIDTH_TILES / 2);
            cameraY = this.y - Math.floor(VIEWPORT_HEIGHT_TILES / 2);
            cameraX = Math.max(0, Math.min(cameraX, MAP_WIDTH - VIEWPORT_WIDTH_TILES));
            cameraY = Math.max(0, Math.min(cameraY, MAP_HEIGHT - VIEWPORT_HEIGHT_TILES));
        }
        draw() {
            const screenX = (this.x - cameraX) * TILE_SIZE;
            const screenY = (this.y - cameraY) * TILE_SIZE;
            ctx.fillStyle = this.color;
            ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
        }
        takeDamage(amount) {
            this.hp -= amount;
            if (this.hp <= 0) {
                this.hp = 0;
                gameOver();
            }
            updateUI();
        }
        addXP(amount) {
            this.xp += amount;
            while (this.xp >= this.xpToNextLevel) {
                this.xp -= this.xpToNextLevel;
                this.levelUp();
            }
            updateUI();
        }
        levelUp() {
            this.level += 1;
            // Exponentially increase required XP: e.g., 100, 200, 400, 800...
            this.xpToNextLevel = Math.floor(100 * Math.pow(2, this.level - 1)); 
            
            // Exponentially increase stats: e.g., Base * Level multiplier
            // Using a simple multiplier here, can be more complex formula
            this.damage = Math.floor(this.baseDamage * Math.pow(1.1, this.level - 1)); 
            this.maxHp = Math.floor(this.baseHp * Math.pow(1.2, this.level - 1));
            this.hp = this.maxHp; // Heal to full on level up
            
            updateUI();
        }
    }

    // --- Enemy & Projectile Management ---

    class Enemy {
      constructor(x, y, type) {
        this.x = x + 0.5; this.y = y + 0.5; this.type = type;
        this.speed = type === 'melee' ? 0.03 : 0.02; 
        this.cooldown = 0;
        this.damage = type === 'melee' ? 5 : 10;
        this.xpValue = currentFloor * 10; // XP scales with floor
        this.coinsValue = Math.floor(Math.random() * 5) + 1 + currentFloor; // Coins scale with floor
      }
      // update and draw functions remain similar to the previous step
      update(player) {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);

        if (dist < 6) { 
          if (this.type === 'melee') {
            this.x += dx / dist * this.speed;
            this.y += dy / dist * this.speed;
          } else if (this.type === 'ranged' && this.cooldown <= 0) {
            projectiles.push(new Projectile(this.x, this.y, dx / dist, dy / dist, this.damage));
            this.cooldown = 1000;
          }
        }
        if (this.cooldown > 0) this.cooldown--;

        // Melee collision check with player
        if (Math.floor(this.x) === player.x && Math.floor(this.y) === player.y && this.type === 'melee') {
            player.takeDamage(this.damage / 10); 
        }
      }

      draw() {
        const screenX = (this.x - cameraX) * TILE_SIZE - TILE_SIZE / 2;
        const screenY = (this.y - cameraY) * TILE_SIZE - TILE_SIZE / 2;
        ctx.fillStyle = this.type === 'melee' ? '#f00' : '#0ff';
        ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
      }
    }

    class Projectile {
      constructor(x, y, dx, dy, damage) {
        this.x = x; this.y = y;
        this.dx = dx * 0.1;
        this.dy = dy * 0.1;
        this.damage = damage;
      }

      update() {
        this.x += this.dx;
        this.y += this.dy;

        const tileX = Math.floor(this.x);
        const tileY = Math.floor(this.y);

        // Check for wall collision (stop at walls)
        if (tileX < 0 || tileX >= MAP_WIDTH || tileY < 0 || tileY >= MAP_HEIGHT || map[tileY][tileX] === 1) {
            return false; 
        }

        // Check for player collision
        if (Math.floor(this.x) === player.x && Math.floor(this.y) === player.y) {
            player.takeDamage(this.damage);
            return false;
        }
        
        return true; 
      }

      draw() {
        const screenX = (this.x - cameraX) * TILE_SIZE;
        const screenY = (this.y - cameraY) * TILE_SIZE;
        ctx.fillStyle = '#ff0';
        ctx.fillRect(screenX, screenY, TILE_SIZE / 2, TILE_SIZE / 2);
      }
    }

    function spawnEnemies() {
      for (let i = 1; i < roomsList.length; i++) {
        const room = roomsList[i];
        for(let j = 0; j < 3; j++){
            let spawnAttempts = 0;
            let spawned = false;
            while(spawnAttempts < 5 && !spawned){
                let x = room.x1 + 1 + Math.floor(Math.random() * (room.x2 - room.x1 - 2));
                let y = room.y1 + 1 + Math.floor(Math.random() * (room.y2 - room.y1 - 2));
                const tooClose = enemies.some(e => Math.hypot(e.x - x, e.y - y) < ENEMY_MIN_SPAWN_DIST) || 
                                 Math.hypot(player.x - x, player.y - y) < ENEMY_MIN_SPAWN_DIST;

                if (!tooClose && map[y][x] === 0) { // Also ensure we aren't spawning on stairs/walls
                    const type = Math.random() > 0.7 ? 'ranged' : 'melee';
                    enemies.push(new Enemy(x, y, type));
                    spawned = true;
                }
                spawnAttempts++;
            }
        }
      }
    }
    
function startNewGame() {
  // Reset game state
  currentFloor = 1;
  gameRunning = true;
  enemies = [];
  projectiles = [];
  roomsList = [];
  map = [];

  // Reset player stats
  player.hp = player.maxHp;
  player.xp = 0;
  player.level = 1;
  player.xpToNextLevel = 100;
  player.damage = player.baseDamage;
  player.coins = 0;

  // Hide skill popup
  document.getElementById("skill-popup").style.display = "none";

  // Regenerate dungeon and enemies
  generateDungeon();
  spawnEnemies();
  updateUI();

  // Restart game loop
  requestAnimationFrame(gameLoop);
}

    function generateSkillTree(points) {
  const tree = document.getElementById("skill-tree");
  tree.innerHTML = "";

  const skills = [
    { name: "Power I", effect: "+1 permanent damage", cost: 1 },
    { name: "Vitality I", effect: "+10 max HP", cost: 1 },
    { name: "Greed I", effect: "+10% coin gain", cost: 1 },
    { name: "Speed I", effect: "+10% move speed", cost: 1 },
    { name: "Power II", effect: "+2 permanent damage", cost: 2 },
    { name: "Vitality II", effect: "+20 max HP", cost: 2 },
    { name: "Greed II", effect: "+20% coin gain", cost: 2 },
    { name: "Speed II", effect: "+20% move speed", cost: 2 },
  ];

  skills.forEach((skill, i) => {
    const btn = document.createElement("button");
    btn.textContent = skill.name;
    btn.title = skill.effect;
    btn.style.margin = "10px";
    btn.style.padding = "10px";
    btn.style.background = "#333";
    btn.style.color = "#fff";
    btn.style.border = "1px solid #666";
    btn.style.cursor = "pointer";

    if (skill.cost > points) {
      btn.disabled = true;
      btn.style.opacity = 0.5;
    }

    tree.appendChild(btn);
  });
}

    // --- Drawing & UI Functions ---

    function drawMap() {
      for (let y = 0; y < VIEWPORT_HEIGHT_TILES; y++) {
        for (let x = 0; x < VIEWPORT_WIDTH_TILES; x++) {
          const mapX = cameraX + x;
          const mapY = cameraY + y;
          
          if (mapX >= 0 && mapX < MAP_WIDTH && mapY >= 0 && mapY < MAP_HEIGHT) {
            const tileType = map[mapY][mapX];
            if (tileType === 1) ctx.fillStyle = "#444";
            else if (tileType === 2) ctx.fillStyle = "#000088"; // Stairs color (Dark Blue)
            else ctx.fillStyle = "#ccc"; // Floor color

            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          }
        }
      }
    }
    
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMap();
        enemies.forEach(enemy => enemy.draw());
        projectiles.forEach(p => p.draw());
        if (player) {
            player.draw();
        }
    }

    function updateUI() {
        if (player) {
            uiHp.textContent = `${player.hp}/${player.maxHp}`;
            uiDmg.textContent = player.damage;
            uiLvl.textContent = player.level;
            uiXp.textContent = `${player.xp}/${player.xpToNextLevel}`;
            uiCoins.textContent = player.coins;
            uiFloorCount.textContent = currentFloor;

            uiHp.style.color = player.hp > (player.maxHp / 2) ? '#0f0' : player.hp > 0 ? '#ff0' : '#f00';
        }
    }
    
   function gameOver() {
  gameRunning = false;
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = 'white';
  ctx.font = '48px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);

  const shards = player.coins;
  const points = Math.floor(shards / 1000);
  document.getElementById("shard-count").textContent = shards;
  document.getElementById("point-count").textContent = points;
  document.getElementById("skill-popup").style.display = "block";
  generateSkillTree(points);
}

    // --- Input Handling & Game Loop ---

    document.addEventListener('keydown', (event) => {
        if (!gameRunning) return;
        pressedKeys[event.key] = true;
      
        if (event.key === "z" || event.key === "Z") {
  gameOver();
}
        if (event.key === " ") {
            enemies = enemies.filter(enemy => {
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 1.5) { 
                    return true;
                } else {
                    // Enemy "dies" when punched (no enemy HP system yet)
                    player.addXP(enemy.xpValue);
                    player.coins += enemy.coinsValue;
                    updateUI();
                    return false; 
                }
            });
        }
    });
    
    document.addEventListener('keyup', (event) => {
        delete pressedKeys[event.key];
    });

    function update(deltaTime) {
        if (!player || !gameRunning) return;

        // --- Player Update (throttled) ---
        let moved = false;
        if (deltaTime - lastMoveTime >= MOVE_DELAY_MS) {
             if (pressedKeys['ArrowUp'] || pressedKeys['w']) {
                moved = player.move(0, -1);
            } else if (pressedKeys['ArrowDown'] || pressedKeys['s']) {
                moved = player.move(0, 1);
            } else if (pressedKeys['ArrowLeft'] || pressedKeys['a']) {
                moved = player.move(-1, 0);
            } else if (pressedKeys['ArrowRight'] || pressedKeys['d']) {
                moved = player.move(1, 0);
            }
        }

        if (moved) {
            lastMoveTime = deltaTime;
        }

        // --- Entity Updates ---
        enemies.forEach(enemy => enemy.update(player));
        projectiles = projectiles.filter(p => p.update());
    }
    

    
    // Main continuous loop
    function gameLoop(timestamp) {
        update(timestamp);
        draw();
        if (gameRunning) {
            requestAnimationFrame(gameLoop);
        }
    }

    // --- Initialization ---

    generateDungeon();
    spawnEnemies();
    // Initialize player level/xp/coins UI with starting values
    player.levelUp(); 
    player.xp = 0;
    player.coins = 0;
    updateUI(); 
    
    // Start the game loop
    requestAnimationFrame(gameLoop);

  </script>
</body>
</html>
